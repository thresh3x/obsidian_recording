	[通过动画可视化数据结构和算法 - VisuAlgo](https://visualgo.net/zh)

#### 排序算法
##### 冒泡排序 - $O(n^2)$
	比较所有相邻两项，如果第一项比第二项大，则交换它们。元素项向上移动至正确的顺序，就像气泡升至表面一样，冒泡排序因此得名。
```js
function bubbleSort(arr) {
    const {length} = arr
    for (let i=0; i < length - 1; i++) {
        for (let j=0; j < length - 1 - i; j++) {
            if (arr[j] > arr[j+1]) {
                [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
            }
        }
    }
    console.log(arr)
}
```

##### 选择排序 - $O(n^2)$
	选择排序算法是一种原址排序算法。大致思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值放在第二位，以此类推。
```js
function selectSort(arr) {
    const {length} = arr
    for (let i=0; i < length - 1; i++) {
        let minIndex = i
        for (let j=i; j < length; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j
            }
        }
        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]
    }
    console.log(arr)
}
```

##### 插入排序 - $O(n^2)$
	插入排序算法大致思路是在循环中暂存当前值，内循环<i的项，大于当前值便覆盖，出内循环把当前值赋值给在内循环中最后一个大于当前值的下标项。
```js
function insertSort(arr) {
    for (let i=1; i < arr.length; i++) {
        const temp = arr[i]
        let j = i
        while (j>0 && arr[j - 1] > temp) {
            arr[j] = arr[j-1]
            j--
        }
        arr[j] = temp
    }
    console.log(arr)
}
```

##### 归并排序
	归并排序是一种分而治之的算法。其思想是将原始数组切分成较小的数组，直到每个小数只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。
```js
function mergeSort(arr) {
    function merge(left, right) {
        let i = 0, j = 0
        const res = []
        while (i < left.length && j < right.length) {
            res.push(
                left[i] < right[j] ? left[i++] : right[j++]
            )
        }
        return res.concat(i < left.length ? left.slice(i) : right.slice(j))
    }

    if (arr.length > 1) {
        const mid = Math.floor(arr.length / 2)
        const left = mergeSort(arr.slice(0, mid))
        const right = mergeSort(arr.slice(mid))
        arr = merge(left, right)
    }
    return arr
}
```

##### 快速排序
	找到一个基准值，比它大的放在右边，比它小的放在左边。右边数组和左边数组递归这个过程，直到数组长度为一。
```js
function quickSort(arr) {
    function qSort(arr, partitionIndex) {
        const partition = arr[partitionIndex]
        const minArr = []
        const maxArr = []
        for (let i=0; i < arr.length; i++) {
            if (i == partitionIndex) continue
            if (arr[i] > partition) {
                maxArr.push(arr[i])
            } else {
                minArr.push(arr[i])
            }
        }
        return [minArr, maxArr]
    }
  
    function getPartition(left, right) {
        return left + Math.round(Math.random() * (right - left))
    }
  
    if (arr.length < 2) return arr
    const partitionIndex = getPartition(0, arr.length - 1)
    let [minArr, maxArr] = qSort(arr, partitionIndex)
    return quickSort(minArr).concat(arr[partitionIndex]).concat(quickSort(maxArr))
}
```

##### 计数排序
	计数排序使用一个用来储存每个元素在原始数组中出现次数的临时数组。在所有元素都计数完成后，临时数组已排好序并可迭代已构建排序后的结果数组。