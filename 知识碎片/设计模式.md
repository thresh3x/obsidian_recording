##### 构造器模式
	通过使用一个构造函数来复用重复代码。
	缺点：公共的方法，会随着每次实例创建而重复创建。

##### 原型模式
	把公共的方法放在原型链上，解决构造函数的缺点。
	es6 class 把方法绑定在原型上，class同用了构造器模式和原型模式。

##### 工厂模式
	由一个工厂对象决定创建某一种产品对象的实例，主要用于创建同一类对象。
	根据传入参数判断返回同一类对象的不同属性，例如userFactor('admin')返回路由权限。

##### 抽象工厂模式
	抽象工厂模式并不直接生成实例，而是用于对产品类簇的创建。
	提取出一个父类配置公共方法与属性，返回应该创建的类而不是实例。

##### 建造者模式
	建造者模式属于创建型模式的一种，提供一种创建复杂对象的方法。它将一个复杂的对象的构建层与表示层相互分离，同样的构建过程可采用不同的表示。
	工厂模式在乎创建后的结果，而建造者关注的是过程。

##### 单例模式
	1. 保证一个类仅有一个实例，并提供一个访问它的全局访问点
	2. 主要解决一个全局使用的类频繁地创建与销毁，占用内存
	es5 自执行函数返回函数里面保存实例闭包，第一次执行赋值闭包实例，后续直接返回闭包实例。
	es6 利用类挂在静态属性，实现es5闭包的效果。
	vue其中的vuex和pinia的store都是使用单例模式实现。

##### 装饰器模式
	装饰器模式能够很好的对已有功能进行拓展，这样不会更改原有代码，方便我们在较少改动下拓展功能。
	请求接口前置函数添加token。ajax

##### 适配器模式
	将一个类的接口转换成客户喜欢的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。
	axios内部在web和node环境做了适配器。

##### 策略模式
	策略模式定义了一系列算法，并将每个算法封装起来，使得它们可以相互替换，并且算法的变化不会影响使用算法的客户。把使用算法的责任和算法的实现分割开来，并委托不同对象对这些算法进行管理。
	该模式主要解决在有多种算法相似的情况下，使用if else带来的复杂和难以维护。它的优点是算法可以自由切换，同时可以避免多重if else判断，有良好的拓展性。
	例如，数据有个状态字段，不同字段要实现的页面展示字段和颜色不同，那么就可以使用一个obj对象保存不同字段对应的返回值。添加新字段的逻辑只需在obj中添加，也避免了多个if else语句。

##### 代理模式
	代理模式proxy，为其他对象提供一种代理以控制这个对象的访问。

##### 观察者模式
	观察者模式包括观察目标和观察者两类对象。一个目标可以有任意数量与之相依赖的观察者。一旦观察目标的状态发生改变，所有的观察者都得到通知。
	优势：目标者和观察者功能耦合度降低，专注自身功能逻辑。观察者被动接收更新，时间上解耦，实时接收目标者更新状态。
	缺点：观察者模式虽然实现了对象间依赖关系的低耦合，但却不能对时间通知进行细分管理，如筛选通知、指定主题时间通知。

##### 发布订阅模式
	1. 观察者和目标相互知道
	2. 发布者和订阅者不用互相知道，提供第三方实现调度，属于经过解耦之后的观察者模式

##### 模块模式
	模块化模式最初被定义为在传统软件工程中为类提供私有和公共封装的一种方法。
	1. 闭包
	2. es6模块化规范

##### 桥接模式
	将抽象部分与它的实现部分分离，使ta'm

